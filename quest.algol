Algorithmically generated adventure game;

BEGIN
  COMMENT Game state is stored in global variables. Could perhaps move to own variables in a procedure;

  COMMENT Variables that describe the world that the player is in;
  COMMENT ---------;

  COMMENT World number, used as seed to generate world;
  INTEGER world;

  COMMENT The world is a 5x5 grid of squares. Each has a landscape type index, the index of any object present (zero if not) and the object strength. Also the index of any monster present (zero if not) and its strength;
  INTEGER ARRAY landscape[0:24];
  INTEGER ARRAY object[0:24];
  INTEGER ARRAY obStrength[0:24];
  INTEGER ARRAY monster[0:24];
  INTEGER ARRAY monStrength[0:24];

  COMMENT The following booleans are set to describe whether the player can exit in this direction from the current location;
  BOOLEAN north, south, west, east;
  
  COMMENT Variables that describe the player state;
  COMMENT ---------;
    
  COMMENT Level number of the player. As level increases, the monsters get tougher;
  INTEGER level;

  COMMENT The current and previouslposition of the player in the world grid;
  COMMENT Previous position used when retreating from a fight;
  INTEGER pos;
  INTEGER lastPos;

  COMMENT Strength and skill level of the player 0-100;
  INTEGER strength;
  INTEGER skill;

  COMMENT Index of the object that the player is carrying, and its strength;
  COMMENT Zero indicates carrying nothing;
  INTEGER carrying;
  INTEGER carryStrength;

  COMMENT Random number generator. Generates an integer between 0 and range (inclusive). Current seed stored in randvar;
  INTEGER randvar;  
  INTEGER PROCEDURE random(range);
  VALUE range; INTEGER range;
  BEGIN
    INTEGER r;
    INTEGER mask;  
    range := range + 1;
    
    COMMENT Multiply and add, then mask the bottom 31 bits;
    randvar := randvar * 214013 + 2531011;
    mask := 65535; COMMENT 2 to the power 16 minus 1;
    elliott(3, 0, randvar, 0, 0, 3, mask); COMMENT acc := randvar, acc AND= mask;
    elliott(2, 0, randvar, 0, 0, 0, 0); COMMENT randvar := acc, nop;
    r := randvar - (randvar DIV range) * range;  
    random := r;
  END random;

  COMMENT Helper procedure for making a TRUE/FALSE decision based on a probability. Probability is expressed as an integer percentage 0 to 100;
  BOOLEAN PROCEDURE decide(below);
  VALUE below; INTEGER below;
  BEGIN
    INTEGER i, num, j;    
    num := random(50) + 20;
    FOR i := 0 STEP 1 UNTIL num DO j := random(100);
    decide := random(100) LESS below;
  END decide;

  COMMENT Outputs a copy of this program and game state to a paper tape that can be loaded from initial instructions;
  COMMENT Once loaded, this procedure will continue executing immediately after the dump instruction;
  PROCEDURE savegame;
  BEGIN
    PRINT #Saving game...?;
    dump;
  END savegame;
  
  COMMENT Saves a copy of the game if and only if the least significant keyboard digit is pressed;
  PROCEDURE saveifpressed;
  BEGIN
    INTEGER i;
    SWITCH sw := no;
    i := 1;
    elliott(7, 0, 0, 0, 0, 3, i);
    elliott(4, 2, no, 0, 0, 0, 0);
    savegame;
  no:    
  END saveifpressed;
  
  COMMENT Prints a pseudo-random name based on the provided seed;  
  PROCEDURE name(seed);
  VALUE seed; INTEGER seed;
  BEGIN
    INTEGER len, temp, i, j;    
    temp := randvar;
    randvar := seed;
    len := random(2) + 1;
    FOR i := 1 STEP 1 UNTIL len DO BEGIN
      j := random(8);
      IF j = 1 THEN PRINT #ro?;
      IF j = 2 THEN PRINT #nee?;
      IF j = 3 THEN PRINT #dor?;
      IF j = 4 THEN PRINT #na?;
      IF j = 5 THEN PRINT #se?;
      IF j = 6 THEN PRINT #fo?;
      IF j = 7 THEN PRINT #nir?;      
    END for;
    randvar := temp;
  END name;
  
  COMMENT Initialises the world with landscape, objects and monsters. The random seed needs to have been initialised in advance with the world number;
  PROCEDURE prepare;
  BEGIN
    INTEGER x, y, p;
    FOR x := 0 STEP 1 UNTIL 4 DO BEGIN
      FOR y := 0 STEP 1 UNTIL 4 DO BEGIN
        p := x + y * 5;
        landscape[p] := random(4) + 1;
        object[p] := random(4);
        obStrength[p] := random((level + 1) * 10) + 1;
        monster[p] := random(4);
        monStrength[p] := random((level + 1) * 10 + 1);
      END;      
    END;
    pos := 3 + 2 * 5;
    lastPos := pos;
    monster[pos] := 0;
  END prepare;

  COMMENT Prints the name of an object whose index is num and strength is strn. If full is true prints a long description, otherwise prints a short description with no strength;
  COMMENT TODO- load object names from tape so they vary between worlds;
  PROCEDURE printObj(num, strn, full);
  VALUE num, strn, full; INTEGER num, strn; BOOLEAN full;
  BEGIN
    SWITCH ob := nothing,sword,wand,stone,gold;
    SWITCH ss := done;
    GOTO ob[num+1];
  nothing: PRINT #nothing?; GOTO done;
  sword: PRINT #a sword?;
    IF full THEN PRINT # of strength ?, strn;
    GOTO done;
  wand: PRINT #a magic wand?; 
    IF full THEN PRINT # of magic ?, strn;
    GOTO done;
  stone: PRINT #a stone?; 
    IF full THEN PRINT # of weight ?, strn, #kg?;
    GOTO done;
  gold: PRINT #some gold?; 
    IF full THEN PRINT # of value ?, strn, # coins?;
    GOTO done;
  done:
    PRINT #?;
  END printObj;


  COMMENT Prints the name of the monster whose index is num;  
  PROCEDURE printMon(num);
  VALUE num; INTEGER num;
  BEGIN
    SWITCH ob := nothing,spider,troll,goblin,ghost;
    SWITCH ss := done;
    GOTO ob[num+1];
  nothing: PRINT #no monster?; GOTO done;
  spider: PRINT #a huge spider?; GOTO done;
  troll: PRINT #a vicious troll?; GOTO done;
  goblin: PRINT #a nasty goblin?; GOTO done;
  ghost: PRINT #an angry ghost?; GOTO done;
  done:
    PRINT #?;
  END printMon;
  
  COMMENT Make the monster in the current location attack the player;
  PROCEDURE monAttack;
  BEGIN
    INTEGER damage;
    SWITCH ss := finished;
    
    IF monster[pos] = 0 THEN GOTO finished;
    printMon(monster[pos]);
    PRINT # attacks you ?;
    damage := random(monStrength[pos]) DIV 2;
    IF damage LESSEQ monStrength[pos] DIV 6 THEN
      PRINT #causing no damage. ?
    ELSE BEGIN
      PRINT #causing ?, damage, # damage. ?;
      strength := strength - damage; 
    END damage;
    
    COMMENT Random occurrences;
    damage := random(10);
    IF damage = 1 AND carrying NOTEQ 0 AND object[pos] = 0 THEN BEGIN
      PRINT #You drop ?; printObj(carrying,0,false); PRINT #. ?;
      object[pos] := carrying;
      carrying := 0;
      GOTO finished;
    END damage1;
    
    IF damage = 1 AND carrying NOTEQ 0 THEN BEGIN
      PRINT #The ?; printObj(carrying,0,false); PRINT # breaks. ?;
      carrying := 0;
      GOTO finished;
    END damage1;
    
  finished:
  END monAttack;
  
  COMMENT Print the description of the current location;
  COMMENT TODO- Load descriptions from tape to allow them to vary between worlds;
  PROCEDURE look;
  BEGIN
    INTEGER here;
    SWITCH scape := trees,clearing,pool,hillside,hut;
    SWITCH ss := done;
    
    here := landscape[pos];
    PRINT #You are ?;
    GOTO scape[here];
  trees: PRINT #in dense forest?; GOTO done;
  clearing: PRINT #in a clearing in the trees?; GOTO done;
  pool: PRINT #beside a pool?; GOTO done;
  hillside: PRINT #on a wooded hillside?; GOTO done;
  hut: PRINT #beside a woodland hut?; GOTO done;
  done:
    PRINT #. ?;
    IF (object[pos] + monster[pos] NOTEQ 0) THEN BEGIN 
      PRINT #There is ?;
      IF (monster[pos] NOTEQ 0) THEN BEGIN 
        printMon(monster[pos]);
        PRINT # of strength ?,monStrength[pos];
      END monster;
      IF (object[pos] NOTEQ 0) THEN BEGIN
        IF (monster[pos] NOTEQ 0) THEN PRINT # guarding ?;
        printObj(object[pos],obStrength[pos],true);
      END object;
      PRINT # here. ?;
    END;  
  END look;
  
  COMMENT Cause the player to attack the monster in the current location;
  PROCEDURE youAttack;
  BEGIN
    INTEGER damage;
    SWITCH ss := finished;
    
    IF monster[pos] = 0 THEN GOTO finished;
    
    PRINT #You attack ?; printMon(monster[pos]);
    IF carryStrength NOTEQ 0 THEN BEGIN
      PRINT # with ?;
      printObj(carrying,carryStrength,true);
      PRINT # ?;
    END;
    
    damage := random(strength) DIV 2 + carryStrength;
    IF damage LESSEQ monStrength[pos] THEN
      PRINT #causing no damage. ?
    ELSE BEGIN
      PRINT #causing ?, damage, # damage. ?;
      monStrength[pos] := monStrength[pos] - damage; 
    END damage;
    
    IF monStrength[pos] LESS 1 THEN BEGIN
      PRINT printMon(monster[pos]), # dies. ?;
      monster[pos] := 0;
      look;
    END monStrength;
        
  finished:
  END youAttack;
  
  COMMENT Print a status summary for the player;
  PROCEDURE status;
  BEGIN
    BOOLEAN found;
    found := false;
    PRINT #Level ?,special(1),level,sameline,# explorer on planet ?; name(world); PRINT #.#L??;
    PRINT #Your strength is ?,strength, #, and your skill is ?,skill,#. ?;
    PRINT #You are carrying ?,printObj(carrying,carryStrength,true),#.#L2??;    
  END status;

  COMMENT Non-blocking function to get the current input state of the lower 9 bits on the input board;  
  INTEGER PROCEDURE getin;
  BEGIN
    INTEGER result;
    INTEGER mask;
    
    result := 0;
    mask := 511;
    elliott(7, 0, 0, 0, 0, 3, mask);
    elliott(2, 0, result, 0, 0, 0, 0);
    getin := result;    
  END getin;

  COMMENT Print a context-sensitive list of options to to the player based on the current game state;
  PROCEDURE options;
  BEGIN
    SWITCH ss := finished;
    
    PRINT ##L?What next#u? ?;  
    north := pos GR 4;
    south := pos LESS 20;
    west := pos - (pos DIV 5) * 5 GR 0;
    east := pos - (pos DIV 5) * 5 LESS 4;
    
    COMMENT If there is a monster only give a flee option and dont even give that if this is the first move;
    IF monster[pos] NOTEQ 0 THEN BEGIN
      IF lastPos NOTEQ pos THEN PRINT #1 Flee, ?;
      IF object[pos] NOTEQ 0 THEN PRINT #16 Steal, ?;
      PRINT #32 Attack, ?;    
      GOTO finished;
    END monster;
    
    COMMENT No monster;
    IF north THEN PRINT #1 North, ?;
    IF south THEN PRINT #2 South, ?;
    IF west THEN PRINT #4 West, ?;
    IF east THEN PRINT #8 East, ?;
    IF object[pos] NOTEQ 0 THEN PRINT #16 Take, ?;
    
  finished:
    PRINT #64 Status, 128 Quit#L??;
  END options;

  COMMENT Blocking function to get the next instruction from the player. If the input buttons need reseting it will prompt the player to do this before accepting input;  
  INTEGER PROCEDURE command;
  BEGIN
    INTEGER result;   
    SWITCH ss := loop, loop2;
    
    IF getin NOTEQ 0 THEN BEGIN
      PRINT ##L?Hit A2 reset#L??;
  loop:
      IF getin NOTEQ 0 THEN GOTO loop;
    END getin;
  
    options;
    
  loop2:
    result := getin;
    IF result = 0 THEN GOTO loop2;
    
    command := result;
  END command;

  COMMENT Take the object in the current location;
  PROCEDURE take;
  BEGIN
    INTEGER temp, temp1;
    
    temp := 0;
    temp1 := 0;
    IF object[pos] NOTEQ 0 THEN BEGIN 
      temp := object[pos];
      temp1 := obStrength[pos];
      PRINT #You take ?, printObj(object[pos],0,false), #. ?;
    END object;
    
    object[pos] := carrying;
    obStrength[pos] := carryStrength;
    carrying := temp;
    carryStrength := temp1;
        
    IF object[pos] NOTEQ 0 THEN PRINT #You drop ?, printObj(object[pos],0,false), #.?;
  END take;

  COMMENT Act on the command provided by the user and print the results. Returns zero if the player is still alive after the command completes;  
  INTEGER PROCEDURE game(cmd);
  VALUE cmd; INTEGER cmd;
  BEGIN
    INTEGER result;
    SWITCH ss := finished, doneMon;
    
    result := 0;
    IF monster[pos] NOTEQ 0 THEN BEGIN
      IF cmd = 1 AND lastPos NOTEQ pos THEN BEGIN
        INTEGER temp;
        
        PRINT #You attempt to flee. ?;
        IF decide(66) THEN PRINT #You are successful. ? ELSE monAttack;
        temp := pos; pos := lastPos; lastPos := temp;
        look;
        GOTO finished;
      END cmd;
      
      IF cmd = 16 THEN BEGIN
        COMMENT steal;
        PRINT #You attempt to steal ?; printObj(object[pos],0,false); PRINT #. ?;
        IF decide(33) THEN take ELSE PRINT #You are unsuccessful. ?;      
      END cmd;
      
      IF cmd = 32 THEN BEGIN
        COMMENT attack;
        youAttack;
      END cmd;
      GOTO doneMon;
    END monster;
  
    COMMENT No monster;  
    IF cmd = 1 AND north THEN BEGIN lastPos := pos; pos := pos - 5; PRINT #You go north. ?; look; GOTO finished; END;
    IF cmd = 2 AND south THEN BEGIN lastPos := pos; pos := pos + 5; PRINT #You go south. ?; look; GOTO finished; END;
    IF cmd = 4 AND west THEN BEGIN lastPos := pos; pos := pos - 1; PRINT #You go west. ?; look; GOTO finished; END;
    IF cmd = 8 AND east THEN BEGIN lastPos := pos; pos := pos + 1; PRINT #You go east. ?; look; GOTO finished; END;
    IF cmd = 16 THEN BEGIN take; GOTO finished; END;
  
  doneMon:
    IF cmd = 64 THEN BEGIN status; GOTO finished; END;
    IF cmd = 128 THEN result := 1;
  finished:
    PRINT ##L??;
    game := result;
  END game;

  COMMENT Main game loop. First initialise the game state;
  randvar := 125;
  skill := 0;
  strength := 50;
  world := 0;
  level := 0;
  lastPos := 0;

  BEGIN
    INTEGER choice;
    SWITCH ss := loop;
    punch(3);
    sameline; special(1); leadzero(#?);
    carrying := 0; carryStrength := 0;
    
    COMMENT If the least significant keyboard digit is pressed, output a copy of this game to tape;
    saveifpressed;
    
    PRINT #Teleporting... ?;
    prepare;
    PRINT #You materialise on planet ?; name(world); PRINT #.#L??;
    status;
    look;
  loop:
    monAttack;
    IF strength LESS 1 THEN BEGIN
      PRINT #Out of strength, you collapse and die.?;
    END ELSE
      IF game(command) = 0 THEN GOTO loop;
    PRINT #GAME OVER#L2??;
  END;  
END program;
